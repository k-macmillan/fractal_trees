% !TeX root = ../hw4.tex
\section{Generating a Simple Fractal Tree}

\subsection{Statement}

Generate a fractal tree by repeating a ``fork'' shape with default angle of $45^\circ$.
Scale each repetition of the whole fractal by $\frac{1}{3}$ each iteration.

Experiment with different angles.

\subsection{Method}\label{sec:l-system-method}

\subsubsection{Lindenmayer Systems}
Lindenmayer Systems are commonly referred to as
\href{https://en.wikipedia.org/wiki/L-system}{L-Systems}. An L-System takes a
series of production rules and applies them to an
\href{https://en.wikipedia.org/wiki/Axiom}{axiom}, or initial string for a
defined number of iterations. To define these L-Systems our approach utilizes a
JSON configuration file to store the system's variables:

\begin{minted}{json}
{
    "unit": 1,
    "angle": 0.392699082,
    "radius": null,
    "proportion": null,
    "axiom": "G",
    "iterations": 6,
    "randomness": null,
    "rules": {
        "G": "F+[[G]-G]-F[-FG]+G",
        "F": "FF"
    }
}
\end{minted}

A description for each of the JSON parameters is given in \autoref{tab:json_format}.

\begin{table}[H]
    \centering
    \caption{JSON config file parameters}\label{tab:json_format}
    \begin{tabular}{@{}cl@{}}
        \toprule
        \textbf{Name} & \textbf{Description}                                 \\ \midrule
        unit          & Length of a segment                                  \\
        angle         & Angle (radians) applied to \mintinline{text}{+-^v<>} \\
        radius        & Radius for segments                                  \\
        proportion    & Changes radius to a proportion of length             \\
        axiom         & Initial string                                       \\
        iterations    & Number of times to iterate                           \\
        randomness    & Perturbation applied to angle                        \\
        rules         & Denotes what becomes of characters                   \\ \bottomrule
    \end{tabular}
\end{table}

% \todoinline[caption=Define an L-System]{Define an L-System, production rules, and specify the meaning of the different commands.}

\subsubsection{The Lindenmayer System for the Given Problem}
The problem required us to ``shrink'' the original to 1/3 size and apply it to
each angled protrusion. We accomplished that by coming up with an L-System
that grew each previous iteration by a factor of 3 each time it went through a
new iteration. This system is given in \autoref{code:prob1_json}.

\begin{listing}[H]
    \begin{minted}{json}
        {
            "unit": 1,
            "angle": 0.785398163,
            "radius": null,
            "proportion": null,
            "axiom": "F",
            "iterations": 7,
            "randomness": null,
            "rules": {
                "F": "GGG[-F][F][+F]",
                "G": "GG"
            }
        }
    \end{minted}
    \caption{The JSON configuration for the given problem}\label{code:prob1_json}
\end{listing}

We were tasked with changing the angle to 90° which resulted in a
Christmas tree-like structure. We were also tasked with changing the angle to
120° and it resulted in something similar to a
\href{https://en.wikipedia.org/wiki/Sierpi\%C5\%84ski\_triangle}{Sierpiński triangle}.
All three versions are viewable via
\href{https://sketchfab.com/macattackftw/collections/problem-1}{Sketchfab}.

\begin{itemize}
    \item \href{https://sketchfab.com/3d-models/prob1-45-a97f7475b6964b9c930796ba985ac255}{45 degrees}
    \item \href{https://sketchfab.com/3d-models/8c7a25615cee4fb4a51ab3deeae154a0}{90 degrees}
    \item \href{https://sketchfab.com/3d-models/b36c6e912ee548b9a549bd8e0bb273c8}{120 degrees}
\end{itemize}

% \todoinline[caption=Give l-system for given problem]{Give the L-System for given problem and discuss how it might be improved or modified.}

\subsubsection{Extending the Lindenmayer Systems to 3D}
The book mentioned symbols to expand the generation into different dimensions.
We borrowed some of those symbols to generate L-Systems that expanded in the
$x$, $y$, and $z$ dimensions. We applied this
concept to the 45° version of problem 1 and it resulted in a very
\href{https://sketchfab.com/3d-models/prob1-3d-236e501897a945d0a3eb5e4cba37fa3a}{symmetrical tree}.
The JSON configuration for the given 3D rendering is shown in \autoref{code:prob1_3D_json}.

\begin{listing}[H]
    \begin{minted}{json}
        {
            "unit": 1,
            "angle": 0.785398163,
            "radius": null,
            "proportion": null,
            "axiom": "F",
            "iterations": 3,
            "randomness": null,
            "rules": {
                "F": "GGG[-F][F][+F][vF][^F][<F][>F]",
                "G": "GG"
            }
        }
    \end{minted}
    \caption{Problem 1 3D JSON}\label{code:prob1_3D_json}
\end{listing}

Transitioning to 3D space was incredibly simple due to Blender's mathutils
Matrix module as seen in the
\autoref{code:roll_pitch_yaw}. We spent a lot of
time attempting to manipulate Quaternions but found the mathutils module met
all of our requirements and didn't give us a headache.

\begin{listing}[H]
    \begin{minted}{python}
        def yaw(self, angle):
            """Yaw the Turtle around its local Z axis."""
            self.mat = matmul(self.mat, Matrix.Rotation(angle, 4, "Z"))

        def pitch(self, angle):
            """Pitch the Turtle around its local Y axis."""
            self.mat = matmul(self.mat, Matrix.Rotation(angle, 4, "Y"))

        def roll(self, angle):
            """Roll the Turtle around its local X axis."""
            self.mat = matmul(self.mat, Matrix.Rotation(angle, 4, "X"))
    \end{minted}
    \caption{Roll, Pitch, Yaw code}\label{code:roll_pitch_yaw}
\end{listing}

Angle commands such as \mintinline{text}{^} were mapped to pitch function described in
the \autoref{code:roll_pitch_yaw}. So the turtle
would pitch $\theta$ and if the angle command was \mintinline{text}{v} it would pitch
$-\theta$.

% \todoinline[caption=Defined new 3D commands]{
%     Show how to add more commands to extend the L-Systems into 3D.

%     Mention that we implemented this as the book suggested --- by creating a 3D turtle that can yaw, pitch, and roll.

%     Give minimal examples of each command.
% }

\subsubsection{Further Extensions of the Lindenmayer Systems}
Another concept the book mentioned was moving forward without drawing a line.
This was accomplished with symbols \mintinline{text}{f} and \mintinline{text}{g}. Utilizing this
concept we were able to reproduce the
\href{https://sketchfab.com/3d-models/cantor-f645d6ae69a748a283a737f44660c5f6}{Cantor Set}.

We were making plant-like structures so we decided that anything over length 1
would be a ``branch'' and anything else was a ``leaf''. This led to much more
plant-like visualization of the L-Systems. A good example of this can be seen
in \autoref{fig:a_3d} and \autoref{fig:prob1_3d}. We did not have to stop
at 2 colors. We could have added any number of colors and based it on the
length or on the iteration. We chose 2 because it demonstrated the concept and
made the resulting system look better.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.75\textwidth]{figures/L-systems/a3d.png}
    \caption[3D L-system Example]{A 3D representation of the book Figure 7.24a}\label{fig:a_3d}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.75\textwidth]{figures/L-systems/prob13d.jpg}
    \caption[3D Representation of Problem 1]{A 3D representation of problem 1}\label{fig:prob1_3d}
\end{figure}

We experimented further with radii proportionality and randomness but the
results didn't look as good. Radii proportionality did not look good as a
locked radii and would probably be better if done with a function instead of a
scaler. Randomness broke the fractal nature of the designs. We found that there
were many cases where patterns would loop back on themselves and generate
multiple identical cylinders. Applying the perturbation to angle or length
resulted in a complete breakdown of the fractal symmetry. It is possible that
some simple L-System variations may have looked better but we did not find one.

% \todoinline[caption=Further extending the L-System]{Discuss how to add color, radii proportionality, and randomness}
% \todoinline[caption=Add randomness]{
%     Implement randomness.
%     I can think of two ways to do so:
%     First, add an \texttt{r} command that perturbs the immediately following command.
%     This would introduce randomness, but at regular intervals.

%     Second, add a randomness parameter to the constructor, so that if it's set, apply perturbations at random.

%     Mention that adding randomness breaks fractals with backtracking.
% }

\subsection{Implementation}\label{sec:l-sys-implementation}
Implementation of this problem was done in three parts: \mintinline{text}{grammar},
\mintinline{text}{graphics}, and \mintinline{text}{turtle}.

\subsubsection{Grammar}
This section identified which symbols we would utilize as well as how it would
build the final string. Symbols were defined within a
\href{https://docs.python.org/3/library/stdtypes.html#frozenset}{frozenset}:
\mintinline{python}{symbols}. The function: \mintinline{python}{iapply} essentially
utilizes a generator to apply production rules to the \mintinline{text}{axiom} of the
given iteration.

\subsubsection{Graphics}
Graphics assigns the initial conditions specified in the JSON file.
The various function mappings are assigned such as:

\begin{minted}{python}
self.mappings = {"F": self.turtle.move, "^": self.turtle.pitch}
\end{minted}

We then iterate through the string (\mintinline{python}{commands}), applying the
appropriate mappings. We keep track of consecutive move commands to determine
segment length. This serves to reduce the number of cylinders we have to draw
and it allows us to assign a color scheme based on length.

Cylinders are saved in a dictionary format:
\begin{minted}{python}
    cylinders.append(
        {
            "from": start,
            "to": end,
            "radius": self.radius,
            "material": "Branch" if length > 1 else "Leaf",
            "length": length,
        }
    )
\end{minted}

\begin{table}[H]
    \centering
    \caption{Dictionary of Cylinders}\label{table:dict_cylinders}
    \begin{tabular}{@{}ll@{}}
        \toprule
        \textbf{Name} & \textbf{Description}               \\ \midrule
        from          & Origin                             \\
        to            & Destination                        \\
        radius        & Radius for segment                 \\
        material      & Branch or Leaf dependent on length \\
        length        & Cylinder length                    \\ \bottomrule
    \end{tabular}
\end{table}

\autoref{table:dict_cylinders} defines what each attribute in a cylinder
means. Due to the quirks of Blender we determined it was better to create a
single cylinder and then copy it, so for each length we generate a master. The
master is copied for each cylinder of the same length, while the copy has the
appropriate \mintinline{python}{from - to} applied. This application is done through the
\mintinline{python}{draw} function. We started to have \mintinline{text}{axioms} that
were hundreds of thousands of characters long. Speed became an issue with
sufficient iterations so we developed a batch system.  We specify the number of
jobs we want to run on via command line:

\mintinline{shell}{./batch.sh data/b3d.json --jobs 32}

Essentially this chops up the \mintinline{text}{cylinders} list into 32 pieces and runs
them concurrently. Runtimes went from 45 minutes to a few seconds. The
batch process fires up \mintinline{text}{--jobs N} instances of Blender. This can
quickly consume all RAM. We had to play around with the limits of our
individual machines to find the maximums. This batch process allowed us to
break 19,000 cylinders which was a hard threshold we were struggling to surpass.
We were able to generate over 400,000 cylinders without issue utilizing the
batch method.

Individually generated \mintinline{text}{.blend} files are joined into a
single entity which reduces the size of the stored 3D object. If the resulting
\mintinline{text}{.fbx} file is under 50MB we were able to upload it to
\href{https://sketchfab.com/macattackftw/models}{Sketchfab}.

\subsubsection{Turtle}
The turtle is a very simple python class. Blender's mintinline{python}{mathutils} library makes turtles
very easy to implement. Prior to finding this we spent several days trying to
get Quaternions working. The \mintinline{python}{turtle} class only has a few
functions:

\begin{itemize}
    \item push
    \item pop
    \item move
    \item roll
    \item pitch
    \item yaw
    \item position
\end{itemize}

Roll, pitch, and yaw are simply matrix multiplications applied to the existing
rotation. Move is a matrix multiplication applied to the existing position.
Push and pop are utilized for setting and then returning to that position
respectively.

% \todoinline{
%     McGough has seemed to like my (brief) discussion of my previous implementations.
%     We should not give the whole thing, just the interesting bits and pieces.
% }

\subsubsection{Existing Implementations}
There are a number of existing implementations for Lindenmayer Systems in Python --- at least one of which is even done in three dimensions.

The first implementation of L-Systems that we found was actually a \LaTeX{} Tikz implementation.
It's quite easy to use.
\autoref{fig:latex-lsystem} shows the result of the Tikz code shown in \autoref{code:latex-lsystem}.

\begin{figure}[H]
    \centering

    \pgfdeclarelindenmayersystem{Fractal plant}{
    \rule{X -> F-[[X]+X]+F[+FX]-X}
    \rule{F -> FF}
    }

    \begin{tikzpicture}
        \draw [green!50!black, rotate=90][
            l-system={
                    Fractal plant,
                    axiom=X,
                    order=5,
                    step=2pt,
                    angle=25
                }
        ] lindenmayer system;
    \end{tikzpicture}
    \caption{A fractal plant generated with \LaTeX}\label{fig:latex-lsystem}
\end{figure}

\begin{listing}[H]
    \begin{minted}{latex}
        \documentclass[tikz, border=1mm]{standalone}

        \usetikzlibrary{lindenmayersystems}

        \pgfdeclarelindenmayersystem{Fractal plant}{
            \rule{X -> F-[[X]+X]+F[+FX]-X}
            \rule{F -> FF}
        }

        \begin{document}
        \begin{tikzpicture}
            \draw [green!50!black, rotate=90][
                l-system={
                        Fractal plant,
                        axiom=X,
                        order=5,
                        step=2pt,
                        angle=25
                    }
            ] lindenmayer system;
        \end{tikzpicture}
        \end{document}
    \end{minted}
    \caption{A fractal plant with \LaTeX}\label{code:latex-lsystem}
\end{listing}

We also found numerous 2D Python implementations. Some of which are listed below, ranked by their usefulness.
\begin{enumerate}
    \item \href{http://www.4dsolutions.net/ocn/lsystems.html}{4dsolutions}
    \item \href{https://hackaday.io/project/11721-python-l-system}{Hackaday project}
    \item \href{https://interactivepython.org/courselib/static/thinkcspy/Strings/TurtlesandStringsandLSystems.html}{How To Think Like A Computer Scientist project}
\end{enumerate}

The original paper \textit{The Algorithmic Beauty of Plants} can be found online at \url{http://algorithmicbotany.org/papers/\#abop}.

The original idea to make a variant of the Lindenmayer system in three dimensions came from \href{https://stackoverflow.com/questions/42257676/l-systems-and-the-stack-in-maya}{this Stack Overflow post}.
However, in that post the author is using the Maya Python API, which has very little documentation and supporting material online.
Further, Maya is quite expensive (\$3,000+) for non-educational use, so there was little practical advantage to learning it on the side.
Thus we decided to use the free, open source modeling software \href{https://www.blender.org/}{Blender}.

Blender has excellent mathematics libraries for performing 3D graphics manipulation, which was exactly what we wanted for this project.
We spent roughly a week before another round of Googling produced the \href{https://github.com/lemurni/lpy-lsystems-blender-addon}{Lindenmaker Blender addon}.
Lindenmaker is a Python library that adds a new panel to Blender for producing L-system trees.
Lindenmaker is the result of the bachelor's thesis available \href{https://www.cg.tuwien.ac.at/research/publications/2017/LEOPOLD-2017-ALG/LEOPOLD-2017-ALG-thesis.pdf}{here}.

Due to the spirit of the assignment we decided to avoid blindly using the Lindenmaker addon without implementing our own solution.
However, we still took inspiration from Lindenmaker's implementation of the 3D turtle because we struggled getting quaternion transformations to apply to each object's \textit{local} reference frame.

\subsubsection{Computing the Vertices}
I have no clue what kind of voodoo mathamagic you used to do this.
\todoinline[caption=Implementation of the vertex computation]{
    Discuss the \mintinline{python}{Graphics.compute(lstring)} method and its implementation.
    Be sure to include the data structure it returns and how the material is set.

    Also include the proportional radii, and randomness (once it's implemented).
}

% \subsubsection{Adding Cylinders to the 3D Scene}
% Covered in Graphics subsubsection. I don't think he cares about the details that much in regards to Blender.
% \todoinline[caption=Implementation of adding objects to the scene]{
%     Show how to add a single cylinder to the scene, and mention that it slowed down Blender substantially.

%     Show how to fix this by duplicating cylinders, but mention that there was still a substantial slowdown for large fractals.
% }

% \subsubsection{Parallel Scene Creation}
% He's not going to care about the code to join blender files, though the process is explained above.
% \todoinline[caption=Implementation of batch processing]{
%     Discuss the general idea of the batch mode, but there's no need to give actual code --- other than how to join two files.
% }

\subsubsection{Usage}
We initially designed this to be ran in a single thread with no concurrent
usage. This proved inadequate for sufficiently large L-Systems. The recommended
mode of operation is batch and to do so simply generate a JSON file in
the format shown in \autoref{code:prob1_json}. Save the file
in whatever folder you wish, then run:

\mintinline{shell}{./batch.sh data/myJSON.json --jobs N}

To keep things neat we recommend placing the JSON file in the data
folder. Jobs (\mintinline{text}{N}) can be from 1 to as much RAM as your system can
handle. It is not recommended to go beyond 32 jobs unless you have more than
16GB of RAM.

The final file will be \mintinline{text}{data/myJSON.blend}. All of the
\mintinline{text}{myJSON-job-*-.blend} are from the \mintinline{text}{N} jobs scheduled and are the
individual components of the final \mintinline{text}{.blend} file.

% \todoinline[caption=Script usage]{
%     Discuss how to use each of the scripts we created, spending the most time on \texttt{blender.py} and \texttt{batch.sh}.

%     Make sure to point out that the \mintinline{python}{bpy} and \mintinline{python}{mathutils} libraries are provided by Blender, and that to use them we need to run our scripts in funky ways.
% }

\subsection{Results}
Results of Problem one can be seen in \autoref{fig:prob1_45},
\autoref{fig:prob1_90}, and \autoref{fig:prob1_120}. The \mintinline{text}{.fbx} files can be
found on
\href{https://sketchfab.com/macattackftw/collections/problem-1}{Sketchfab}.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.75\textwidth]{figures/L-systems/prob1-45}
    \caption{Problem 1 where $\theta = 45^\circ$}\label{fig:prob1_45}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.75\textwidth]{figures/L-systems/prob1-90}
    \caption{Problem 1 where $\theta = 90^\circ$}\label{fig:prob1_90}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.75\textwidth]{figures/L-systems/prob1-120}
    \caption{Problem 1 where $\theta = 120^\circ$}\label{fig:prob1_120}
\end{figure}

% \subsubsection{The Lindenmayer System for the Given Problem}
% \todoinline[caption=results for given problem]{
%     Show our results for the given problem.

%     Show the production rules, and generated graphics.
%     Play with the scale and the yaw angle.
% }

% \todoinline[caption=Move experimentation to problem 2]{
%     Leave the 3D and other experimentation to problem 2, because it asks you to experiment, and we can get more mileage out of it there.
% }

\subsection{Conclusion}
L-Systems are great for generation of interesting fractal patterns. We
generated several additional variations which can be found
\href{https://sketchfab.com/macattackftw/models}{here}. We wanted a visually
appealing implementation and we accomplished that. The L-System itself is
rather straightforward. Storing cylinder start/stop locations was relatively
simple, the bulk of our work was spent on visualizing and optimizing to work
with Blender. While that was not the goal of the problem it was useful to
experiment with an unfamiliar API and integrate our product with it.

There could be future work in expanding color schemes, variable radii, and
further optimizing blender usage (such as chopping up the JSON file based on
batches). We thoroughly explored L-Systems and it was a fun project.
